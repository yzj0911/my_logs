# Http

# 计算机网络

## 请简述TCP\UDP的区别

TCP和UDP是OSI模型中的运输层的协议。TCP提供可靠的通信传输,而UDP则常用于让广播和细节控制交给应用的通信传输。

两者的区别大致如下:

- TCP面向连接,UDP面向非连接即发送数据前不需要建立连接
- TCP面向可靠的服务,UDP无法保证
- TCP面向字节流,UDP面向报文
- TCP数据传输较慢,UDP传输快

## 请简单说下你了解的端口对应的服务

![img](https://pic1.zhimg.com/80/v2-e584c505e895441d7b52c8f3c02c9770_720w.png)

## 说一说TCP报文首部

1. 源端口和目的端口，各占2个字节，分别写入源端口和目的端口；
2. 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
3. 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；
4. 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
5. 保留，占6位，保留今后使用，但目前应都位0；
6. 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
7. 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
8. 推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
9. 复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
10. 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
11. 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
12. 窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
13. 检验和，占2字节，校验首部和数据这两部分；
14. 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；
15. 选项，长度可变，定义一些其他的可选的参数。

## 说一说TCP的三次握手

1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 说一说TCP的四次挥手

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## 为什么需要“四次挥手”

tcp是全双工通信，服务端和客服端都能发送和接收数据。

tcp在断开连接时，需要服务端和客服端都确定对方将不再发送数据。

**第1次挥手**

由客户端向服务端发起，服务端收到信息后就能确定客户端已经停止发送数据。

**第2次挥手**

由服务端向客户端发起，客户端收到消息后就能确定服务端已经知道客户端不会再发送数据。

**第3次握手**

由服务端向客户端发起，客户端收到消息后就能确定服务端已经停止发送数据。

**第4次挥手**

由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。

**为什么不是3次挥手**

在客服端第1次挥手时，服务端可能还在发送数据。

## HTTP有哪些方法

HTTP1.0定义了三种请求方法:GET、POST和HEAD方法。

HTTP1.1新增了五种请求方法:OPTIONS,PUT,DELETE,TRACE和CONNECT

## 这些方法具体作用是什么

- GET:通常用于请求服务器发送某些资源
- HEAD:请求资源的头部信息,并且这些头部与HTTP GET方法请求时返回的一致.该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否需要下载，以此可以节约带宽资源。
- OPTIONS:用于获取目前的资源所支持的通信选项
- POST:发送数据给服务器
- PUT:用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
- DELETE:用于删除指定的资源
- PATCH:用于对资源进行部分修改
- CONNECT:HTTP/1.1协议中预留给能够连接改为管道方式的代理服务器
- TRACE:回显服务器收到的请求,主要用于测试或诊断

## GET和POST的区别是什么

先下结论，**GET 和 POST 方法没有实质区别**，只是报文格式不同。

GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。

报文格式上，不带参数时，最大区别就是第一行方法名不同

POST 方法请求报文第一行是这样的 `POST /uri HTTP/1.1 \r\n`

GET 方法请求报文第一行是这样的 `GET /uri HTTP/1.1 \r\n`

是的，不带参数时他们的区别就仅仅是报文的前几个字符不同而已

带参数时报文的区别呢？ 在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中



## PUT和POST有什么区别

PUT和POST方法的区别是PUT是幂等的,POST是非幂等的。PUT指向的URI指向的是单一资源,POST可以指向资源集合。

## PUT和PATCH有什么区别

PUT和PATCH都是更新资源,而PATCH用来对已知资源进行局部更新。

## HTTP的请求报文是什么

请求报文有4部分组成:

- 请求行
- 请求头部
- 空行
- 请求体

![2019-06-14-11-33-37](https://segmentfault.com/img/remote/1460000020690213?w=500&h=273)

## HTTP的响应报文是什么样的

请求报文由4部分组成:

- 响应行
- 响应头
- 空行
- 响应体

![2019-06-14-11-37-02](https://segmentfault.com/img/remote/1460000020690214?w=596&h=285)

## HTTP的头部有哪些

通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部

- Cache-Control 控制缓存 ✨
- Connection 连接管理、逐条首部 ✨
- Upgrade 升级为其他协议
- via 代理服务器的相关信息
- Wraning 错误和警告通知
- Transfor-Encoding 报文主体的传输编码格式 ✨
- Trailer 报文末端的首部一览
- Pragma 报文指令
- Date 创建报文的日期

请求首部字段（Reauest Header Fields）:客户端向服务器发送请求的报文时使用的首部

- Accept 客户端或者代理能够处理的媒体类型 ✨
- Accept-Encoding 优先可处理的编码格式
- Accept-Language 优先可处理的自然语言
- Accept-Charset 优先可以处理的字符集
- If-Match 比较实体标记（ETage） ✨
- If-None-Match 比较实体标记（ETage）与 If-Match相反 ✨
- If-Modified-Since 比较资源更新时间（Last-Modified）✨
- If-Unmodified-Since比较资源更新时间（Last-Modified），与 If-Modified-Since相反 ✨
- If-Rnages 资源未更新时发送实体byte的范围请求
- Range 实体的字节范围请求 ✨
- Authorization web的认证信息 ✨
- Proxy-Authorization 代理服务器要求web认证信息
- Host 请求资源所在服务器 ✨
- From 用户的邮箱地址
- User-Agent 客户端程序信息 ✨
- Max-Forwrads 最大的逐跳次数
- TE 传输编码的优先级
- Referer 请求原始放的url
- Expect 期待服务器的特定行为

响应首部字段（Response Header Fields）:从服务器向客户端响应时使用的字段

- Accept-Ranges 能接受的字节范围
- Age 推算资源创建经过时间
- Location 令客户端重定向的URI ✨
- vary 代理服务器的缓存信息
- ETag 能够表示资源唯一资源的字符串 ✨
- WWW-Authenticate 服务器要求客户端的验证信息
- Proxy-Authenticate 代理服务器要求客户端的验证信息
- Server 服务器的信息 ✨
- Retry-After 和状态码503 一起使用的首部字段，表示下次请求服务器的时间

实体首部字段（Entiy Header Fields）:针对请求报文和响应报文的实体部分使用首部

- Allow 资源可支持http请求的方法 ✨
- Content-Language 实体的资源语言
- Content-Encoding 实体的编码格式
- Content-Length 实体的大小（字节）
- Content-Type 实体媒体类型
- Content-MD5 实体报文的摘要
- Content-Location 代替资源的yri
- Content-Rnages 实体主体的位置返回
- Last-Modified 资源最后的修改资源 ✨
- Expires 实体主体的过期资源 ✨

## 聊一聊HTTP的状态码有哪些？

2XX 成功

- 200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨
- 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
- 202 Accepted 请求已接受，但是还没执行，不保证完成请求
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 206 Partial Content，进行范围请求 ✨

3XX 重定向

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL ✨
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义相同

4XX 客户端错误

- 400 bad request，请求报文存在语法错误 ✨
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨
- 403 forbidden，表示对请求资源的访问被服务器拒绝 ✨
- 404 not found，表示在服务器上没有找到请求的资源 ✨
- 408 Request timeout, 客户端请求超时
- 409 Confict, 请求的资源可能引起冲突

5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误 ✨
- 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
- 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本

## HTTP的keep-alive是干什么的？

在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。

keep-alive的优点：

- 较少的CPU和内存的使用（由于同时打开的连接的减少了）
- 允许请求和应答的HTTP管线化
- 降低拥塞控制 （TCP连接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭TCP连

## 为什么有了HTTP为什么还要HTTPS？

https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。

## HTTPS是如何保证安全的？

过程比较复杂，我们得先理解两个概念

对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密

对称加密虽然很简单性能也好，但是无法解决首次把秘钥发给对方的问题，很容易被hacker拦截秘钥。

非对称加密：

1. 私钥 + 公钥= 密钥对
2. 即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密
3. 因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方
4. 然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密

非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。

解决方案：

那么结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

此时又带来一个问题，中间人问题：

如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。

所以这个时候需要一个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。

证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等

![2019-06-14-12-30-18](https://segmentfault.com/img/remote/1460000020690215?w=321&h=159)

但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。

数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。

当别人把他的证书发过来的时候,我再用同样的Hash算法,再次生成消息摘要，然后用CA的公钥对数字签名解密,得到CA创建的消息摘要,两者一比,就知道中间有没有被人篡改了。

这个时候就能最大程度保证通信的安全了

## HTTP2相对于HTTP1.x有什么优势和特点

### 二进制分帧

帧:HTTP/2数据通信的最小单位消息:指HTTP/2中逻辑上的HTTP消息。例如请求和响应等,消息由一个或多个帧组成。

流:存在于连接中的一个虚拟通道。流可以承载双向消息,每个流都有一个唯一的整数ID

HTTP/2采用二进制传输数据,而非HTTP 1.x的文本格式,二进制协议解析起来更高效。

### 服务器推送

服务端可以在发送页面HTML时主动推送其它资源,而不用等到浏览器解析到相应位置,发送请求响应。例如服务端可以主动把JS和CSS文件推送给客户端,而不需要客户端解析HTML时在发送这些请求。

### 头部压缩

HTTP/1.x会在请求和响应中重复地携带不常变得、冗长的头部数据,给网络带来额外的负担。

- HTTP/2在客户端和服务器端使用"首部表"来跟踪和存储之前发送的键-值对,对于相同的数据,不再通过每次请求和响应发送
- 首部表在HTTP/2的连接存续期始终存在,由客户端和服务器渐近地更新
- 每个新的首部键-值对要么被追加到当前表的末尾,要么替换表中之前的值。

### 多路复用

HTTP 1.x中,如果想并发多个请求,必须使用多个TCP连接,且浏览器为了控制资源,还会对单个域名有6-8个的TCP链接请求限制。

HTTP2中:

- 同个域名所有通信都在单个连接上完成
- 单个连接可以承载任意数量的双向数据流
- 数据流以消息的形式发送,而消息又由一个或者多个帧组成,多个帧之间可以乱序发送,因为根据帧首部的流标识可以重新组装。

HTTP协议:超文本传输协议
浏览器与服务端之间传输数据的协议，底层的传输协议为TCP。
HTTP则为应用层协议，负责定义传输数据的格式。


HTTP协议分为1.0与1.1两个版本。现在常用为1.1版本。

协议规定客户端与服务端通讯方式为:一次请求一次响应
即:客户端发起请求，服务端接收到请求后向客户端发送响应。
服务端不会主动发送内容给客户端。采取"一问一答"的形式。


HTTP对请求与响应分别定义了格式。并且，无论是请求还是
响应中发送的字符(不含正文部分内容)都只能符合ISO8859-1
编码字符(如:数字，字母，符号)。像中文等其他字符都需要
经过处理后才可以发送。


HTTP请求格式

一个HTTP请求分为三部分组成:请求行，消息头，消息正文


1:请求行

请求行分为三部分:
请求方法 资源路径 协议(CRLF)  

method url protocol(CRLF)

例如:
GET /index.html HTTP/1.1(CRLF)


请求行以CRLF结束
CR:回车符,asc编码中对应数字13
LF:换行符,asc编码中对应数字10



2:消息头

消息头由若干行表示，每行表示一个具体的头信息
每个头信息格式分为两部分:
消息头名字:消息头的值(CRLF)
name:value(CRLF)
每个消息头都以CRLF结尾。
最后一个消息头结尾处会有两个CRLF，第一个表示最后一个
消息头结束，第二个表示消息头部分结束。

例如:
Host: localhost:8080(CRLF)
Connection: keep-alive(CRLF)
Cache-Control: max-age=0(CRLF)
Upgrade-Insecure-Requests: 1(CRLF)
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36(CRLF)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8(CRLF)
Accept-Encoding: gzip, deflate, sdch(CRLF)
Accept-Language: zh-CN,zh;q=0.8(CRLF)(CRLF)
3:消息正文

正文部分不是必须部分，消息正文是2进制数据。是客户端
在发送请求时发送给服务端客户提交的数据。这些数据可能
是注册信息，上传的图片等。具体数据是什么类型以及这些
2进制数据有多少字节会在消息头中具体说明。若消息头中
没有说明消息正文内容则这个请求中是不含有正文的。



下面是浏览器发送给服务端的一个请求(不含有正文部分)

GET /index.html HTTP/1.1CRLF
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8



HTTP
响应
HTTP
响应格式也分为三部分:状态行，响应头，响应正文


状态行格式:
protorol status-code status-reason

协议版本 状态码 状态描述


状态代码有五类:
1xx:信息响应类，表示接受到请求并继续处理

2xx:处理成功响应类,表示动作被成功接收兵处理

3xx:重定向类，为了完成指定的动作，必须接受下一步处理

4xx:客户端错误类，表示客户端请求包含错误的语法或不能正确的执行

5xx:服务端错误类，服务端不能正确的处理一个正确的请求。   
常见的:

200:一切正常

302:服务端要求客户端重定向到指定路径

404:用于请求资源未找到

500:服务端处理异常


响应头格式:
响应头的格式与请求中的消息头格式一致。



响应正文:
响应正文也是二进制数据，用于将客户端请求的资源等
信息发送回给客户端。该正文具体表示的介质类型以及占用
的字节长度会在响应头中有所描述。



一个HTTP响应大致内容:

HTTP/1.1 200 OK(CRLF)
Content-Type:text/html(CRLF)
Content-Length:224586(CRLF)(CRLF)
1101010101001.....2进制字节数据





HTTPS和HTTP的区别主要为以下四点：
1. https协议需要到ca申请证书，一般免费证书很少，需要交费。
2. http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssål加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。


![](https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/网路七大层.jpg)
三次握手，四次挥手

![](https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/http.png)

为什么4次挥手？
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

