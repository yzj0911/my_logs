<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>GMP - YZJ 的博客</title><meta name="Description" content="Hello 来了就别走了，进来留下文章"><meta property="og:title" content="GMP" />
<meta property="og:description" content="GMP模型 M M代表内核级线程,一个M就是一个线程,goroutine就是跑在M之上的;M是一个很大的结构,里面维护了小对象内存cache、当" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/gmp/" /><meta property="og:image" content="http://example.org/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-12T21:26:15+08:00" />
<meta property="article:modified_time" content="2022-04-12T21:26:15+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/logo.png"/>

<meta name="twitter:title" content="GMP"/>
<meta name="twitter:description" content="GMP模型 M M代表内核级线程,一个M就是一个线程,goroutine就是跑在M之上的;M是一个很大的结构,里面维护了小对象内存cache、当"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/posts/images/avatar.webp"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://example.org/gmp/" /><link rel="prev" href="http://example.org/%E7%A9%BA%E5%88%87%E7%89%87%E5%92%8Cnil%E5%88%87%E7%89%87/" /><link rel="next" href="http://example.org/interface/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "GMP",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/gmp\/"
        },"genre": "posts","wordcount":  12341 ,
        "url": "http:\/\/example.org\/gmp\/","datePublished": "2022-04-12T21:26:15+08:00","dateModified": "2022-04-12T21:26:15+08:00","publisher": {
            "@type": "Organization",
            "name": "YZJ"},"author": {
                "@type": "Person",
                "name": "yzj"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="YZJ 的博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/posts/images/avatar.webp"
        data-srcset="/posts/images/avatar.webp, /posts/images/avatar.webp 1.5x, /posts/images/avatar.webp 2x"
        data-sizes="auto"
        alt="/posts/images/avatar.webp"
        title="/posts/images/avatar.webp" />YZj 的个人博客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/" title="YZJ 的博客"> 文章 </a><a class="menu-item" href="/tags/" title="YZJ 的博客"> 标签 </a><a class="menu-item" href="/categories/" title="YZJ 的博客"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="请输入搜索文章" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="YZJ 的博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/posts/images/avatar.webp"
        data-srcset="/posts/images/avatar.webp, /posts/images/avatar.webp 1.5x, /posts/images/avatar.webp 2x"
        data-sizes="auto"
        alt="/posts/images/avatar.webp"
        title="/posts/images/avatar.webp" />YZj 的个人博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="请输入搜索文章" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="YZJ 的博客">文章</a><a class="menu-item" href="/tags/" title="YZJ 的博客">标签</a><a class="menu-item" href="/categories/" title="YZJ 的博客">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">GMP</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/yzj0911" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>yzj</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-04-12">2022-04-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 12341 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 25 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="true">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#m">M</a></li>
    <li><a href="#g">G</a>
      <ul>
        <li><a href="#p">P</a></li>
      </ul>
    </li>
    <li><a href="#sched">Sched</a></li>
    <li><a href="#gmp调度">GMP调度</a></li>
  </ul>

  <ul>
    <li><a href="#pmg中切换正在等待或者阻塞的协程">PMG中切换正在等待或者阻塞的协程</a>
      <ul>
        <li><a href="#gopark函数">gopark函数</a></li>
      </ul>
    </li>
    <li><a href="#goready函数">goready函数：</a>
      <ul>
        <li>
          <ul>
            <li><a href="#一golang调度器的由来">一、Golang“调度器”的由来？</a>
              <ul>
                <li><a href="#1-单进程时代不需要调度器">(1) 单进程时代不需要调度器</a></li>
                <li><a href="#2多进程线程时代有了调度器需求">(2)多进程/线程时代有了调度器需求</a></li>
                <li><a href="#3协程来提高cpu利用率">(3)协程来提高CPU利用率</a></li>
              </ul>
            </li>
            <li><a href="#n1关系">N:1关系</a></li>
            <li><a href="#11-关系">1:1 关系</a></li>
            <li><a href="#mn关系">M:N关系</a>
              <ul>
                <li><a href="#4go语言的协程goroutine">(4)Go语言的协程goroutine</a></li>
                <li><a href="#5被废弃的goroutine调度器">(5)被废弃的goroutine调度器</a></li>
              </ul>
            </li>
            <li><a href="#二goroutine调度器的gmp模型的设计思想">二、Goroutine调度器的GMP模型的设计思想</a>
              <ul>
                <li><a href="#1gmp模型">(1)GMP模型</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#有关p和m的个数问题">有关P和M的个数问题</a></li>
        <li><a href="#p和m何时会被创建">P和M何时会被创建</a>
          <ul>
            <li>
              <ul>
                <li><a href="#2调度器的设计策略">(2)调度器的设计策略</a></li>
                <li><a href="#3-go-func--调度流程">(3) go func()  调度流程</a></li>
                <li><a href="#4调度器的生命周期">(4)调度器的生命周期</a></li>
                <li><a href="#5可视化gmp编程">(5)可视化GMP编程</a></li>
              </ul>
            </li>
            <li><a href="#三go调度器调度场景过程全解析">三、Go调度器调度场景过程全解析</a>
              <ul>
                <li><a href="#1场景1">(1)场景1</a></li>
                <li><a href="#2场景2">(2)场景2</a></li>
                <li><a href="#3场景3">(3)场景3</a></li>
                <li><a href="#4场景4">(4)场景4</a></li>
                <li><a href="#5场景5">(5)场景5</a></li>
                <li><a href="#6场景6">(6)场景6</a></li>
                <li><a href="#7场景7">(7)场景7</a></li>
                <li><a href="#8场景8">(8)场景8</a></li>
                <li><a href="#9场景9">(9)场景9</a></li>
                <li><a href="#10场景10">(10)场景10</a></li>
                <li><a href="#11场景11">(11)场景11</a></li>
              </ul>
            </li>
            <li><a href="#四小结">四、小结</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="gmp模型">GMP模型</h1>
<h2 id="m">M</h2>
<p>M代表内核级线程,一个M就是一个线程,goroutine就是跑在M之上的;M是一个很大的结构,里面维护了小对象内存cache、当前执行的goroutine、随机数发生器</p>
<p>等等。M的PC寄存器存储着指向G的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g0</span> <span class="o">*</span><span class="nx">g</span> <span class="c1">// 带有调度栈的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gsignal</span> <span class="o">*</span><span class="nx">g</span> <span class="c1">// 处理信号的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tls</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mstartfn</span> <span class="kd">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">curg</span>	<span class="o">*</span><span class="nx">g</span> <span class="c1">//当前运行的goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">caughtsig</span> <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span>		<span class="nx">puintptr</span> <span class="c1">//关联p和执行的go代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nextp</span>	<span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">id</span>		<span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mallocing</span> <span class="kt">int32</span> <span class="c1">// 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">spinning</span> <span class="kt">bool</span> <span class="c1">// m是否out of work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">blocked</span> <span class="kt">bool</span> <span class="c1">// m是否被阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">inwb</span>	<span class="kt">bool</span> <span class="c1">// m是否在执行写屏蔽
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">printlock</span> <span class="kt">int8</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">incgo</span> <span class="kt">bool</span> <span class="c1">//m在执行cgo吗
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fastrand</span>      <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ncgocall</span>      <span class="kt">uint64</span>      <span class="c1">// cgo调用的总数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ncgo</span>          <span class="kt">int32</span>       <span class="c1">// 当前cgo调用的数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">park</span>          <span class="nx">note</span>
</span></span><span class="line"><span class="cl">    <span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span> <span class="c1">// 用于链接allm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">schedlink</span>     <span class="nx">muintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mcache</span>        <span class="o">*</span><span class="nx">mcache</span> <span class="c1">// 当前m的内存缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lockedg</span>       <span class="o">*</span><span class="nx">g</span> <span class="c1">// 锁定g在当前m上执行，而不会切换到其他m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">createstack</span>   <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// thread创建的栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="g">G</h2>
<p>G代表一个goroutine,它有一个自己的栈,instrtuction pointer和其他的信息(正在等待的channel等等),用于调度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stack</span> <span class="nx">stack</span> <span class="c1">//描述了真实的内存,包括上下界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">m</span> <span class="o">*</span><span class="nx">m</span> <span class="c1">// 当前的m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sced</span> <span class="nx">gobuf</span> <span class="c1">// goroutine切换时,用于保存g的上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">param</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 用于传递参数, 睡眠时其他goroutine可以设置param, 唤醒时该goroutine可以获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomicstatus</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stackLock</span>	<span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">goid</span> <span class="kt">int64</span> <span class="c1">//goroutine的ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">waitsince</span> <span class="kt">int64</span> <span class="c1">// g被阻塞的大体时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lockedm</span> <span class="o">*</span><span class="nx">m</span> <span class="c1">// G被锁定只在这个m上运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pc</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span> <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ret</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lr</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bp</span> <span class="nx">uinptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>保存了当前的栈指针、计数器、当然还有g自身,这里记录自身g的指针是为了快速访问到goroutine中的信息。</p>
<h3 id="p">P</h3>
<p>P代表Processor,逻辑处理器,它的主要用途是用来执行goroutine的,所以它也维护了一个goroutine队列,里面存储了所有需要它来执行的goroutine,P/M需要进行绑定,构成一个执行单元。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">id</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">status</span> <span class="kt">uint32</span> <span class="c1">// 状态可以为pidle/prunning/...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">link</span> 	<span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">schedtick</span> <span class="kt">uint32</span> <span class="c1">//每调度一次加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">syscalltick</span> <span class="kt">uint32</span> <span class="c1">//每调度一次系统调用加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">m</span>			<span class="nx">muintptr</span> <span class="c1">// 回链到关联的m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mcache</span>		<span class="o">*</span><span class="nx">mcache</span>
</span></span><span class="line"><span class="cl">    <span class="nx">racectx</span>		<span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">goidcache</span>	<span class="kt">uint64</span> <span class="c1">//goroutine的ID的缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">goidcacheend</span> <span class="kt">uint64</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 可运行的goroutine的队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runqhead</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">runqtail</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">runq</span>	<span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">runnext</span> <span class="nx">guintptr</span> <span class="c1">// 下一个运行的g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sudogbuf</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">palloc</span> <span class="nx">persistentAlloc</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">pad</span> <span class="p">[</span><span class="nx">sys</span><span class="p">.</span><span class="nx">CacheLineSize</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="sched">Sched</h2>
<p>Sched代表调度器,它维护有存储M和G的队列以及调度器的一些状态信息等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">goidgen</span>  <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lastpoll</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">lock</span> <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// idle状态的m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// idle状态的m个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// lockde状态的m个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mcount</span>       <span class="kt">int32</span>    <span class="c1">// 创建的m的总数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// m允许的最大个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">ngsys</span> <span class="kt">uint32</span> <span class="c1">// 系统中goroutine的数目，会自动更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// idle的p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">npidle</span>     <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nmspinning</span> <span class="kt">uint32</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 全局的可运行的g队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runqhead</span> <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">runqtail</span> <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">runqsize</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// dead的G的全局缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gflock</span>       <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gfreeStack</span>   <span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gfreeNoStack</span> <span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ngfree</span>       <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sudog的缓存中心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sudoglock</span>  <span class="nx">mutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="gmp调度">GMP调度</h2>
<p>新创建的Goroutine会存放在Global全局队列中,等待Go调度器进行调度,随后Goroutine被分配给其中的一个逻辑处理器P,并放到这个逻辑处理器对应的Local本地运行队列中,最终等待被逻辑处理器P执行即可。在M与P绑定后,M会不断从P的Local队列中无锁地取出G,并切换到G的堆栈执行,当P的Local队列中没有G时,再从Global队列中获取一个G,当Global队列中也没有待运行的G时,则尝试从其他的P窃取部分G来执行相当于P之间的负载均衡。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://github.com/KeKe-Li/data-structures-questions/raw/master/src/images/65.jpg"
        data-srcset="https://github.com/KeKe-Li/data-structures-questions/raw/master/src/images/65.jpg, https://github.com/KeKe-Li/data-structures-questions/raw/master/src/images/65.jpg 1.5x, https://github.com/KeKe-Li/data-structures-questions/raw/master/src/images/65.jpg 2x"
        data-sizes="auto"
        alt="https://github.com/KeKe-Li/data-structures-questions/raw/master/src/images/65.jpg"
        title="img" /></p>
<p>从上图可以看到,有2个物理线程M,每一个M都拥有一个处理器P,每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()设置,它其实也就代表了真正的并发度,即有多少个goroutine可以同时运行。</p>
<p>图中灰色的那些goroutine并没有运行,而是处于ready的就绪态,正在等待被调度。P维护着这个队列(称之为runqueue),Go语言里,启动一个goroutine很容易:go function 就行,所以每有一个go语句被执行,runqueue中队列就在其末尾加入一个goroutine,在下一个调度点,就从runqueue中取出一个goroutine执行。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/GMP.jpeg"
        data-srcset="https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/GMP.jpeg, https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/GMP.jpeg 1.5x, https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/GMP.jpeg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/GMP.jpeg"
        title="https://raw.githubusercontent.com/yzj0911/my_logs/main/content/images/GMP.jpeg" /></p>
<h1 id="golang-gmp模式golang-的调度模式">golang GMP模式（golang 的调度模式）</h1>
<p>CSP（communicating sequential processes）并发模型。不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。不要以共享内存的方式来通信，相反，要通过通信来共享内存。</p>
<ul>
<li>M指的是Machine，一个M直接关联了一个内核线程。</li>
<li>P指的是”processor”，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。</li>
<li>G指的是Goroutine，其实本质上也是一种轻量级的线程。</li>
</ul>
<p>M关联了一个内核线程，通过调度器P（上下文）的调度，可以连接1个或者多个G,相当于把一个内核线程切分成了了N个用户线程，M和P是一对一关系（但是实际调度中关系多变），通过P调度N个G（P和G是一对多关系），实现内核线程和G的多对多关系（M:N），通过这个方式，一个内核线程就可以起N个Goroutine，同样硬件配置的机器可用的用户线程就成几何级增长，并发性大幅提高。</p>
<h2 id="pmg中切换正在等待或者阻塞的协程">PMG中切换正在等待或者阻塞的协程</h2>
<h3 id="gopark函数">gopark函数</h3>
<p>gopark函数在协程的实现上扮演着非常重要的角色，用于协程的切换，协程切换的原因一般有以下几种情况：</p>
<ul>
<li>系统调用；</li>
<li>channel读写条件不满足；</li>
<li>抢占式调度时间片结束；</li>
</ul>
<p>gopark函数做的主要事情分为两点：</p>
<ul>
<li>解除当前goroutine的m的绑定关系，将当前goroutine状态机切换为等待状态；</li>
<li>调用一次schedule()函数，在局部调度器P发起一轮新的调度。</li>
</ul>
<p>下面我们来研究一下gopark函数是怎么实现协程切换的。</p>
<p>先看看源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gopark</span><span class="p">(</span><span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">lock</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="nx">waitReasonSleep</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">checkTimeouts</span><span class="p">()</span> <span class="c1">// timeouts may expire while two goroutines keep the scheduler busy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
</span></span><span class="line"><span class="cl">    <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Grunning</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Gscanrunning</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gopark: bad g status&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="nx">lock</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">unlockf</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">reason</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span> <span class="p">=</span> <span class="nx">traceEv</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span> <span class="p">=</span> <span class="nx">traceskip</span>
</span></span><span class="line"><span class="cl">    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// can&#39;t do anything that might move the G between Ms here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mcall</span><span class="p">(</span><span class="nx">park_m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>源码里面最重要的一行就是调用 <code>mcall(park_m)</code> 函数，<code>park_m</code> 是一个函数指针。<code>mcall</code> 在golang需要进行协程切换时被调用，做的主要工作是：</p>
<ol>
<li>切换当前线程的堆栈从g的堆栈切换到g0的堆栈；</li>
<li>并在g0的堆栈上执行新的函数fn(g)；</li>
<li>保存当前协程的信息( PC/SP存储到g-&gt;sched)，当后续对当前协程调用goready函数时候能够恢复现场；
mcall函数执行原理</li>
</ol>
<p>mcall的函数原型是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mcall</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里函数fn的参数g指的是在调用mcall之前正在运行的协程。</p>
<p>我们前面说到，<code>mcall</code>的主要作用是协程切换，它将当前正在执行的协程状态保存起来，然后在<code>m-&gt;g0</code> 的堆栈上调用新的函数。 在新的函数内会将之前运行的协程放弃，然后调用一次<code>schedule()</code>来挑选新的协程运行。 ( 也就是在fn函数里面会调用一次<code>schedule()</code>函数进行一次scheduler的重新调度，让m去运行其余的goroutine )</p>
<p>mcall函数是通过汇编实现的，在asm_amd64.s里面有64位机的实现，源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// func mcall(fn func(*g))
</span></span></span><span class="line"><span class="cl"><span class="c1">// Switch to m-&gt;g0&#39;s stack, call fn(g).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Fn must never return. It should gogo(&amp;g-&gt;sched)
</span></span></span><span class="line"><span class="cl"><span class="c1">// to keep running g.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//DI中存储参数fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取当前正在运行的协程g信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将其状态保存在g.sched变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>    <span class="c1">// save state in g-&gt;sched
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>    <span class="c1">// caller&#39;s PC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">LEAQ</span>    <span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>    <span class="c1">// caller&#39;s SP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// switch to m-&gt;g0 &amp; its stack, call fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MOVQ</span>    <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>
</span></span><span class="line"><span class="cl">    <span class="nx">CMPQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="nx">AX</span>    <span class="c1">// if g == m-&gt;g0 call badmcall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">JNE</span>    <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">JMP</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="nx">SI</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>    <span class="c1">// g = m-&gt;g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 切换到m-&gt;g0堆栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">),</span> <span class="nx">SP</span>    <span class="c1">// sp = m-&gt;g0-&gt;sched.sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 参数AX为之前运行的协程g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">PUSHQ</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="nx">DI</span><span class="p">,</span> <span class="nx">DX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="mi">0</span><span class="p">(</span><span class="nx">DI</span><span class="p">),</span> <span class="nx">DI</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 在m-&gt;g0堆栈上执行函数fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CALL</span>    <span class="nx">DI</span>
</span></span><span class="line"><span class="cl">    <span class="nx">POPQ</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MOVQ</span>    <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall2</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">JMP</span>    <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">    <span class="nx">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的汇编代码我也不是很懂，但是能够大致能够推断出主要做的事情：</p>
<ol>
<li>保存当前goroutine的状态(PC/SP)到g-&gt;sched中，方便下次调度；</li>
<li>切换到m-&gt;g0的栈；</li>
<li>然后g0的堆栈上调用fn；</li>
<li>回到gopark函数里面，我们知道mcall会切换到m-&gt;g0的栈，然后执行park_m函数</li>
</ol>
<p>下面看一下park_m函数源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">park_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">traceGoPark</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waittraceev</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waittraceskip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//线程安全更新gp的状态，置为_Gwaiting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 移除gp与m的绑定关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">dropg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fn</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Schedule it back, never returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重新做一次调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">schedule</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>park_m函数主要做的几件事情就是：</p>
<ol>
<li>线程安全更新goroutine的状态，置为_Gwaiting 等待状态；</li>
<li>解除goroutine与OS thread的绑定关系；</li>
<li>调用schedule()函数，调度器会重新调度选择一个goroutine去运行；</li>
<li>schedule函数里面主要调用路径就是：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">schedule</span><span class="p">()</span><span class="err">–</span><span class="p">&gt;</span><span class="nf">execute</span><span class="p">()</span><span class="err">–</span><span class="p">&gt;</span><span class="nf">gogo</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>gogo函数的作用正好相反，用来从gobuf中恢复出协程执行状态并跳转到上一次指令处继续执行。因此，其代码也相对比较容易理解，当然，其实现也是通过汇编代码实现的。</p>
<h2 id="goready函数">goready函数：</h2>
<p>goready函数相比gopark函数来说简单一些，主要功能就是唤醒某一个goroutine，该协程转换到runnable的状态，并将其放入P的local queue，等待调度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 切换到g0的栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数主要就是切换到g0的栈空间然后执行ready函数。</p>
<p>下面我们看看ready函数源码(删除非主流程代码)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Mark gp ready to run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Mark runnable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span><span class="c1">//g0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">status</span><span class="o">&amp;^</span><span class="nx">_Gscan</span> <span class="o">!=</span> <span class="nx">_Gwaiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad g-&gt;status in ready&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//设置gp状态为runnable，然后加入到P的可运行local queue;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">runqput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">wakep</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in Case we&#39;ve cleared it in newstack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<blockquote>
<p>该文章主要详细具体的介绍Goroutine调度器过程及原理，可以对Go调度器的详细调度过程有一个清晰的理解，花    费4天时间作了30+张图(推荐收藏)，包括如下几个章节。</p>
</blockquote>
<blockquote>
<p>本章节含视频版:
<a href="https://www.bilibili.com/video/BV19r4y1w7Nx" target="_blank" rel="noopener noreffer"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202201/25/58489/rxrnLas6f5.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202201/25/58489/rxrnLas6f5.png!large, https://cdn.learnku.com/uploads/images/202201/25/58489/rxrnLas6f5.png!large 1.5x, https://cdn.learnku.com/uploads/images/202201/25/58489/rxrnLas6f5.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202201/25/58489/rxrnLas6f5.png!large"
        title="https://cdn.learnku.com/uploads/images/202201/25/58489/rxrnLas6f5.png!large" /></a></p>
</blockquote>
<p><code>第一章</code>  Golang调度器的由来</p>
<p><code>第二章</code>   Goroutine调度器的GMP模型及设计思想</p>
<p><code>第三章</code>  Goroutine调度场景过程全图文解析</p>
<h4 id="一golang调度器的由来">一、Golang“调度器”的由来？</h4>
<h5 id="1-单进程时代不需要调度器">(1) 单进程时代不需要调度器</h5>
<p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代”</p>
<p>一切的程序只能串行发生。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/06IoYRyruP.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/06IoYRyruP.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/06IoYRyruP.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/06IoYRyruP.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/06IoYRyruP.png!large"
        title="5-单进程操作系统.png" /></p>
<p>早期的单进程操作系统，面临2个问题：</p>
<p>1.单一的执行流程，计算机只能一个任务一个任务处理。</p>
<p>2.进程阻塞所带来的CPU时间浪费。</p>
<p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p>
<p>后来操作系统就具有了<strong>最早的并发能力：多进程并发</strong>，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<h5 id="2多进程线程时代有了调度器需求">(2)多进程/线程时代有了调度器需求</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/sLve6TagD3.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/sLve6TagD3.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/sLve6TagD3.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/sLve6TagD3.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/sLve6TagD3.png!large"
        title="6-多进程操作系统.png" /></p>
<p>在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p>
<p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p>
<p><strong>怎么才能提高CPU的利用率呢？</strong></p>
<p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/dNWd00AiEZ.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/dNWd00AiEZ.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/dNWd00AiEZ.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/dNWd00AiEZ.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/dNWd00AiEZ.png!large"
        title="7-cpu切换浪费成本.png" /></p>
<p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h5 id="3协程来提高cpu利用率">(3)协程来提高CPU利用率</h5>
<p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</p>
<p>大量的进程/线程出现了新的问题</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗CPU</li>
</ul>
<p>好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。</p>
<p>一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/TfStmYsfyF.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/TfStmYsfyF.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/TfStmYsfyF.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/TfStmYsfyF.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/TfStmYsfyF.png!large"
        title="8-线程的内核和用户态.png" /></p>
<p>这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)&quot;.</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/vgzlKzvOUL.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/vgzlKzvOUL.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/vgzlKzvOUL.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/vgzlKzvOUL.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/vgzlKzvOUL.png!large"
        title="9-协程和线程.png" /></p>
<p>​	看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p>
<p>​		之后，我们就看到了有3中协程和线程的映射关系：</p>
<blockquote>
<h4 id="n1关系">N:1关系</h4>
</blockquote>
<p>N个协程绑定1个线程，优点就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</p>
<p>缺点：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/kfPbThcyRU.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/kfPbThcyRU.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/kfPbThcyRU.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/kfPbThcyRU.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/kfPbThcyRU.png!large"
        title="10-N-1关系.png" /></p>
<blockquote>
<h4 id="11-关系">1:1 关系</h4>
</blockquote>
<p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</p>
<p>缺点：</p>
<ul>
<li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/EhNQY2VCpk.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/EhNQY2VCpk.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/EhNQY2VCpk.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/EhNQY2VCpk.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/EhNQY2VCpk.png!large"
        title="11-1-1.png" /></p>
<blockquote>
<h4 id="mn关系">M:N关系</h4>
</blockquote>
<p>M个协程绑定1个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/ANDQLx3g9U.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/ANDQLx3g9U.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/ANDQLx3g9U.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/ANDQLx3g9U.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/ANDQLx3g9U.png!large"
        title="12-m-n.png" /></p>
<p>​	协程跟线程是有区别的，线程由CPU调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出CPU后，才执行下一个协程。</p>
<p>​</p>
<h5 id="4go语言的协程goroutine">(4)Go语言的协程goroutine</h5>
<p><strong>Go为了提供更容易使用的并发方法，使用了goroutine和channel</strong>。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p>
<p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。</p>
<p>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(runtime调度)</li>
</ul>
<h5 id="5被废弃的goroutine调度器">(5)被废弃的goroutine调度器</h5>
<p>​	好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p>
<p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<blockquote>
<p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/Af6GQ3GSlb.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/Af6GQ3GSlb.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/Af6GQ3GSlb.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/Af6GQ3GSlb.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/Af6GQ3GSlb.png!large"
        title="13-gm.png" /></p>
<p>下面我们来看看被废弃的golang调度器是如何实现的？</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/uWk9pzdREk.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/uWk9pzdREk.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/uWk9pzdREk.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/uWk9pzdREk.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/uWk9pzdREk.png!large"
        title="14-old调度器.png" /></p>
<p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>老调度器有几个缺点：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li>
<li>M转移G会造成<strong>延迟和额外的系统负载</strong>。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了<strong>很差的局部性</strong>，因为G’和G是相关的，最好放在M上执行，而不是其他M&rsquo;。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h4 id="二goroutine调度器的gmp模型的设计思想">二、Goroutine调度器的GMP模型的设计思想</h4>
<p>面对之前调度器的问题，Go设计了新的调度器。</p>
<p>在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/zaZ4nQYcZe.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/zaZ4nQYcZe.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/zaZ4nQYcZe.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/zaZ4nQYcZe.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/zaZ4nQYcZe.png!large"
        title="15-gmp.png" /></p>
<p><strong>Processor，它包含了运行goroutine的资源</strong>，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<h5 id="1gmp模型">(1)GMP模型</h5>
<p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large, https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/Ugu3C2WSpM.jpeg!large"
        title="16-GMP-调度.png" /></p>
<ol>
<li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li>
<li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G&rsquo;时，G&rsquo;优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。</li>
<li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
</ol>
<p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。</p>
<blockquote>
<h3 id="有关p和m的个数问题">有关P和M的个数问题</h3>
</blockquote>
<p>1、P的数量：</p>
<ul>
<li>由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS</code>个goroutine在同时运行。</li>
</ul>
<p>2、M的数量:</p>
<ul>
<li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li>runtime/debug中的SetMaxThreads函数，设置M的最大数量</li>
<li>一个M阻塞了，会创建新的M。</li>
</ul>
<p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p>
<blockquote>
<h3 id="p和m何时会被创建">P和M何时会被创建</h3>
</blockquote>
<p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p>
<p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p>
<h5 id="2调度器的设计策略">(2)调度器的设计策略</h5>
<p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p>
<p>1）work stealing机制</p>
<p>​		当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p>
<p>2）hand off机制</p>
<p>​		当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p>
<p><strong>利用并行</strong>：<code>GOMAXPROCS</code>设置P的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的CPU核进行并行。</p>
<p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p>
<p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p>
<h5 id="3-go-func--调度流程">(3) go func()  调度流程</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large, https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large"
        title="18-go-func调度周期.jpeg" /></p>
<p>从上图我们可以分析出几个结论：</p>
<p>​	1、我们通过 go func()来创建一个goroutine；</p>
<p>​	2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p>
<p>​	3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p>
<p>​	4、一个M调度G执行的过程是一个循环机制；</p>
<p>​	5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p>
<p>​	6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p>
<h5 id="4调度器的生命周期">(4)调度器的生命周期</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/j37FX8nek9.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/j37FX8nek9.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/j37FX8nek9.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/j37FX8nek9.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/j37FX8nek9.png!large"
        title="17-pic-go调度器生命周期.png" /></p>
<p>特殊的M0和G0</p>
<p><strong>M0</strong></p>
<p><code>M0</code>是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p>
<p><strong>G0</strong></p>
<p><code>G0</code>是每次启动一个M都会第一个创建的 goroutine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p>
<p>我们来跟踪一段代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p>
<p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是<code>main.main</code>，<code>runtime</code>中也有1个main函数——<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p>
<h5 id="5可视化gmp编程">(5)可视化GMP编程</h5>
<p>有2种方式可以查看一个程序的GMP的数据。</p>
<p><strong>方式1：go tool trace</strong></p>
<p>trace记录了运行时的信息，能提供可视化的Web页面。</p>
<p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印&quot;Hello World&quot;退出。</p>
<blockquote>
<p>trace.go</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;runtime/trace&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//创建trace文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="s">&#34;trace.out&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//启动trace goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">err</span> <span class="p">=</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//main
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ go run trace.go 
</span></span><span class="line"><span class="cl">Hello World
</span></span></code></pre></td></tr></table>
</div>
</div><p>会得到一个<code>trace.out</code>文件，然后我们可以用一个工具打开，来分析这个文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="err">$</span> <span class="k">go</span> <span class="nx">tool</span> <span class="nx">trace</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">out</span> 
</span></span><span class="line"><span class="cl"><span class="mi">2020</span><span class="o">/</span><span class="mo">02</span><span class="o">/</span><span class="mi">23</span> <span class="mi">10</span><span class="p">:</span><span class="mi">44</span><span class="p">:</span><span class="mi">11</span> <span class="nx">Parsing</span> <span class="nx">trace</span><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">2020</span><span class="o">/</span><span class="mo">02</span><span class="o">/</span><span class="mi">23</span> <span class="mi">10</span><span class="p">:</span><span class="mi">44</span><span class="p">:</span><span class="mi">11</span> <span class="nx">Splitting</span> <span class="nx">trace</span><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="mi">2020</span><span class="o">/</span><span class="mo">02</span><span class="o">/</span><span class="mi">23</span> <span class="mi">10</span><span class="p">:</span><span class="mi">44</span><span class="p">:</span><span class="mi">11</span> <span class="nx">Opening</span> <span class="nx">browser</span><span class="p">.</span> <span class="nx">Trace</span> <span class="nx">viewer</span> <span class="nx">is</span> <span class="nx">listening</span> <span class="nx">on</span> <span class="nx">http</span><span class="p">:</span><span class="c1">//127.0.0.1:33479
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以通过浏览器打开<code>http://127.0.0.1:33479</code>网址，点击<code>view trace</code> 能够看见可视化的调度流程。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/Xr9qi3emlx.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/Xr9qi3emlx.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/Xr9qi3emlx.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/Xr9qi3emlx.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/Xr9qi3emlx.png!large"
        title="19-go-trace1.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/vYyO9YJmam.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/vYyO9YJmam.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/vYyO9YJmam.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/vYyO9YJmam.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/vYyO9YJmam.png!large"
        title="20-go-trace2.png" /></p>
<p><strong>G信息</strong></p>
<p>点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/QLm0KK1hhd.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/QLm0KK1hhd.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/QLm0KK1hhd.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/QLm0KK1hhd.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/QLm0KK1hhd.png!large"
        title="20-go-trace3.png" /></p>
<pre><code>  一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。
</code></pre>
<p>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p><strong>M信息</strong></p>
<p>点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/mYYA4V17yF.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/mYYA4V17yF.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/mYYA4V17yF.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/mYYA4V17yF.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/mYYA4V17yF.png!large"
        title="22-go-trace4.png" /></p>
<p>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</p>
<p><strong>P信息</strong>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/QbWwbth8uN.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/QbWwbth8uN.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/QbWwbth8uN.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/QbWwbth8uN.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/QbWwbth8uN.png!large"
        title="23-go-trace5.png" /></p>
<p>G1中调用了<code>main.main</code>，创建了<code>trace goroutine g18</code>。G1运行在P1上，G18运行在P0上。</p>
<p>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</p>
<p>我们在来看看上面的M信息。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/5kS6NfpQAI.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/5kS6NfpQAI.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/5kS6NfpQAI.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/5kS6NfpQAI.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/5kS6NfpQAI.png!large"
        title="24-go-trace6.png" /></p>
<p>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/EN1OESafVZ.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/EN1OESafVZ.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/EN1OESafVZ.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/EN1OESafVZ.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/EN1OESafVZ.png!large"
        title="25-go-trace7.png" /></p>
<p>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p>
<p><strong>方式2：Debug trace</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ go build trace2.go
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过Debug方式运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nv">GODEBUG</span><span class="o">=</span><span class="nv">schedtrace</span><span class="o">=</span><span class="m">1000</span> ./trace2 
</span></span><span class="line"><span class="cl">SCHED 0ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">0</span> <span class="nv">threads</span><span class="o">=</span><span class="m">4</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">1</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">1</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> 0<span class="o">]</span>
</span></span><span class="line"><span class="cl">Hello World
</span></span><span class="line"><span class="cl">SCHED 1003ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">threads</span><span class="o">=</span><span class="m">4</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">2</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> 0<span class="o">]</span>
</span></span><span class="line"><span class="cl">Hello World
</span></span><span class="line"><span class="cl">SCHED 2014ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">threads</span><span class="o">=</span><span class="m">4</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">2</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> 0<span class="o">]</span>
</span></span><span class="line"><span class="cl">Hello World
</span></span><span class="line"><span class="cl">SCHED 3015ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">threads</span><span class="o">=</span><span class="m">4</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">2</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> 0<span class="o">]</span>
</span></span><span class="line"><span class="cl">Hello World
</span></span><span class="line"><span class="cl">SCHED 4023ms: <span class="nv">gomaxprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">idleprocs</span><span class="o">=</span><span class="m">2</span> <span class="nv">threads</span><span class="o">=</span><span class="m">4</span> <span class="nv">spinningthreads</span><span class="o">=</span><span class="m">0</span> <span class="nv">idlethreads</span><span class="o">=</span><span class="m">2</span> <span class="nv">runqueue</span><span class="o">=</span><span class="m">0</span> <span class="o">[</span><span class="m">0</span> 0<span class="o">]</span>
</span></span><span class="line"><span class="cl">Hello World
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</li>
<li><code>0ms</code>：即从程序启动到输出这行日志的时间；</li>
<li><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</li>
<li><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</li>
<li>t<code>hreads: os threads/M</code>的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</li>
<li><code>spinningthreads</code>: 处于自旋状态的os thread数量；</li>
<li><code>idlethread</code>: 处于idle状态的os thread的数量；</li>
<li><code>runqueue=0</code>： Scheduler全局队列中G的数量；</li>
<li><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</li>
</ul>
<p>下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</p>
<h4 id="三go调度器调度场景过程全解析">三、Go调度器调度场景过程全解析</h4>
<h5 id="1场景1">(1)场景1</h5>
<p>P拥有G1，M1获取P后开始运行G1，G1使用<code>go func()</code>创建了G2，为了局部性G2优先加入到P1的本地队列。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/Pm8LOYcsWQ.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/Pm8LOYcsWQ.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/Pm8LOYcsWQ.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/Pm8LOYcsWQ.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/Pm8LOYcsWQ.png!large"
        title="26-gmp场景1.png" /></p>
<hr>
<h5 id="2场景2">(2)场景2</h5>
<p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/JWDtmKG3rK.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/JWDtmKG3rK.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/JWDtmKG3rK.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/JWDtmKG3rK.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/JWDtmKG3rK.png!large"
        title="27-gmp场景2.png" /></p>
<hr>
<h5 id="3场景3">(3)场景3</h5>
<p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/UpjRxzIBd3.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/UpjRxzIBd3.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/UpjRxzIBd3.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/UpjRxzIBd3.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/UpjRxzIBd3.png!large"
        title="28-gmp场景3.png" /></p>
<hr>
<h5 id="4场景4">(4)场景4</h5>
<p>G2在创建G7的时候，发现P1的本地队列已满，需要执行<strong>负载均衡</strong>(把P1中本地队列中前一半的G，还有新创建G<strong>转移</strong>到全局队列)</p>
<blockquote>
<p>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/chqTgsiuWi.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/chqTgsiuWi.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/chqTgsiuWi.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/chqTgsiuWi.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/chqTgsiuWi.png!large"
        title="29-gmp场景4.png" /></p>
<p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p>
<hr>
<h5 id="5场景5">(5)场景5</h5>
<p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/nukEY92G6D.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/nukEY92G6D.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/nukEY92G6D.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/nukEY92G6D.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/nukEY92G6D.png!large"
        title="30-gmp场景5.png" /></p>
<p>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
<hr>
<h5 id="6场景6">(6)场景6</h5>
<p>规定：<strong>在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/11/58489/2FWNXSuHfX.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/11/58489/2FWNXSuHfX.png!large, https://cdn.learnku.com/uploads/images/202003/11/58489/2FWNXSuHfX.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/11/58489/2FWNXSuHfX.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/11/58489/2FWNXSuHfX.png!large"
        title="31-gmp场景6.png" /></p>
<p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程**（没有G但为运行状态的线程，不断寻找G）**。</p>
<hr>
<h5 id="7场景7">(7)场景7</h5>
<p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：<code>findrunnable()</code>）。M2从全局队列取的G数量符合下面的公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">n</span> <span class="p">=</span> <span class="nf">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">GQ</span><span class="p">)</span><span class="o">/</span><span class="nx">GOMAXPROCS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">GQ</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/0fn8DGqI8N.jpeg!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/0fn8DGqI8N.jpeg!large, https://cdn.learnku.com/uploads/images/202003/12/58489/0fn8DGqI8N.jpeg!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/0fn8DGqI8N.jpeg!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/0fn8DGqI8N.jpeg!large"
        title="32-gmp场景7.001.jpeg" /></p>
<p>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p>
<hr>
<h5 id="8场景8">(8)场景8</h5>
<p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/qn1NRMLqnp.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/qn1NRMLqnp.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/qn1NRMLqnp.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/qn1NRMLqnp.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/qn1NRMLqnp.png!large"
        title="33-gmp场景8.png" /></p>
<p><strong>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列</strong>。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
<hr>
<h5 id="9场景9">(9)场景9</h5>
<p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于<strong>自旋状态</strong>，它们不断寻找goroutine。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/1DjlseEGTT.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/1DjlseEGTT.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/1DjlseEGTT.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/1DjlseEGTT.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/1DjlseEGTT.png!large"
        title="34-gmp场景9.png" /></p>
<p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们<strong>希望当有新goroutine创建时，立刻能有M运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>GOMAXPROCS</code>个自旋的线程(当前例子中的<code>GOMAXPROCS</code>=4，所以一共4个P)，多余的没事做线程会让他们休眠。</p>
<hr>
<h5 id="10场景10">(10)场景10</h5>
<p>​		假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了<strong>阻塞的系统调用</strong>，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/k3HKE9U21M.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/k3HKE9U21M.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/k3HKE9U21M.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/k3HKE9U21M.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/k3HKE9U21M.png!large"
        title="35-gmp场景10.png" /></p>
<h5 id="11场景11">(11)场景11</h5>
<p>G8创建了G9，假如G8进行了<strong>非阻塞系统调用</strong>。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.learnku.com/uploads/images/202003/12/58489/zBvpl8ENSb.png!large"
        data-srcset="https://cdn.learnku.com/uploads/images/202003/12/58489/zBvpl8ENSb.png!large, https://cdn.learnku.com/uploads/images/202003/12/58489/zBvpl8ENSb.png!large 1.5x, https://cdn.learnku.com/uploads/images/202003/12/58489/zBvpl8ENSb.png!large 2x"
        data-sizes="auto"
        alt="https://cdn.learnku.com/uploads/images/202003/12/58489/zBvpl8ENSb.png!large"
        title="36-gmp场景11.png" /></p>
<p>​	M2和P2会解绑，但M2会记住P2，然后G8和M2进入<strong>系统调用</strong>状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
<hr>
<h4 id="四小结">四、小结</h4>
<p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-04-12</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/gmp/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="http://example.org/gmp/" data-title="GMP" data-via="xxxx"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://example.org/gmp/"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="http://example.org/gmp/" data-title="GMP" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="http://example.org/gmp/" data-title="GMP"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://example.org/gmp/" data-title="GMP"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="http://example.org/gmp/" data-title="GMP" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="http://example.org/gmp/" data-title="GMP" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="http://example.org/gmp/" data-title="GMP"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E7%A9%BA%E5%88%87%E7%89%87%E5%92%8Cnil%E5%88%87%E7%89%87/" class="prev" rel="prev" title="空切片和nil切片"><i class="fas fa-angle-left fa-fw"></i>空切片和nil切片</a>
            <a href="/interface/" class="next" rel="next" title="Interface">Interface<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.97.0-DEV">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/yzj0911" target="_blank">yzj</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
