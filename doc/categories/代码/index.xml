<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>代码 - 分类 - lack 的个人博客</title>
        <link>http://xingyys.tech/categories/%E4%BB%A3%E7%A0%81/</link>
        <description>代码 - 分类 - lack 的个人博客</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 31 Jul 2020 14:38:08 &#43;0800</lastBuildDate><atom:link href="http://xingyys.tech/categories/%E4%BB%A3%E7%A0%81/" rel="self" type="application/rss+xml" /><item>
    <title>GPRC 实战</title>
    <link>http://xingyys.tech/posts/go/grpc1/</link>
    <pubDate>Fri, 31 Jul 2020 14:38:08 &#43;0800</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/go/grpc1/</guid>
    <description><![CDATA[GRPC 简介 grpc 是由 google 开发的一款开源，高性能 rpc（远程进程调用协议）使用 Protocol Buffers 作为数据交换格式。
GRPC 安装 golang 使用 grpc 要安装 grpc-go, protoc 和 对应的插件。
安装grpc-go go get -u github.com/golang/protobuf/{proto,protoc-gen-go} go get -u google.golang.org/grpc 如果是国内用户无法连接到 google.golang.org 的话可以使用 VPN。或者直接从 github.com 直接下载源代码再编译安装
git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc go get -u google.golang.org/grpc 安装 protoc golang 要使用 grpc，还需要使用 protoc 工具。因为 golang 不能直接识别 .proto 文件，需要使用 protoc 工具将 .proto 转化成 golang 代码。下面介绍几个平台下安装 protobuf 的方法。
macos macos 下安装直接使用 brew 命令即可。
brew install protobuf linux linux 下需要先从 github.]]></description>
</item><item>
    <title>GPRC 进阶</title>
    <link>http://xingyys.tech/posts/go/grpc2/</link>
    <pubDate>Fri, 31 Jul 2020 14:38:08 &#43;0800</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/go/grpc2/</guid>
    <description><![CDATA[grpc 除了提供四种请求类型之外，还支持很多高级功能：keepalive、请求重试、负载均衡、用户验证等。接下来一一介绍。
GRPC 进阶功能  每个grpc请求都是 stream。
 Keepalive Keepalive 能够让 grpc 的每个 stream 保持长连接状态，适合一些执行时间长的请求。Keepalive 支持在服务端和客户端配置，且只有服务端配置后，客户端的配置才会真正有效。先给出实例的代码在来说明 grpc keepalive 的使用情况：server 实现：
// ... var kaep = keepalive.EnforcementPolicy{ MinTime: 5 * time.Second, // If a client pings more than once every 5 seconds, terminate the connection 	PermitWithoutStream: true, // Allow pings even when there are no active streams } var kasp = keepalive.ServerParameters{ MaxConnectionIdle: 15 * time.Second, // If a client is idle for 15 seconds, send a GOAWAY 	MaxConnectionAge: 30 * time.]]></description>
</item><item>
    <title>Go 结合 etcd</title>
    <link>http://xingyys.tech/posts/go/go%E7%BB%93%E5%90%88etcd/</link>
    <pubDate>Tue, 10 Sep 2019 15:17:42 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/go/go%E7%BB%93%E5%90%88etcd/</guid>
    <description><![CDATA[关于 etcd 的安装和介绍看 这里 。官方的实例可以看 这里
一、连接 首先是关于 golang 如何连接 etcd ，先是简单的连接。
package main import ( &#34;github.com/coreos/etcd/clientv3&#34; &#34;log&#34; &#34;time&#34; ) func connect() { cli, err := clientv3.New(clientv3.Config{ // etcd 集群的地址集合 	Endpoints: []string{&#34;192.168.10.10:2379&#34;}, // 请求超时时间 	DialTimeout: time.Second * 3, }) if err != nil { log.Fatal(&#34;connect etcd cluster: &#34; + err.Error()) } cli.Close() } 还有带 https 和 开启用户验证的连接
func connectTlsAuth() { tlsInfo := transport.TLSInfo{ CertFile: &#34;/tmp/cert.pem&#34;, KeyFile: &#34;/tmp/key.pem&#34;, TrustedCAFile: &#34;/tmp/ca.]]></description>
</item><item>
    <title>Golang使用json格式实现增删查改</title>
    <link>http://xingyys.tech/posts/go/golang%E4%BD%BF%E7%94%A8json%E6%A0%BC%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/</link>
    <pubDate>Wed, 07 Aug 2019 16:43:13 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/go/golang%E4%BD%BF%E7%94%A8json%E6%A0%BC%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/</guid>
    <description><![CDATA[需求和思路 在一般的小项目或者一个小软件,例如客户端之类的小程序中,可能会需要数据的持久化.但是使用一般的数据库(Mysql)之类的不合适.使用sqlite3这种嵌入式的是个较好的方法,但是Go语言中sqlite3的库是C语言的,Cgo不支持跨平台编译.正是由于这种需求,才想到使用json格式将数据直接保存在文件中. 具体的思路是怎么样呢? 在Go语言中如果要将数据转化成json格式的话,有两种格式 struct 和 map. 如果同时需要增删查改功能的话,将map作为中间格式是比较合适的.接下来我们就来实现它.
查询操作 这种操作的实现比较简单,直接将文件中的数据读取出来,使用json库反序列化就可以了. 代码如下 :
type Product struct { Name string `json:&#34;name&#34;` Num int `json:&#34;num&#34;` } func findAll() { ps := make([]Product, 0) data, err := ioutil.ReadFile(&#34;./index.json&#34;) if err != nil { log.Fatal(err) } // 这里参数要指定为变量的地址 	err = json.Unmarshal(data, &amp;ps) if err != nil { log.Fatal(err) } fmt.Println(ps) } 添加操作 添加的实现实在查询的基础上的,我们需要先查询文件中的数据库,并转化为map格式,再将struct也转化为map格式(这里要使用反射),合并map,json序列化,最后保存在文件中.代码如下:
func create() { fields := make([]map[string]interface{}, 0) p1 := &amp;Product{ Name: &#34;Blog&#34;, Num: 2, } _, _ = json.]]></description>
</item><item>
    <title>golang打包和解包</title>
    <link>http://xingyys.tech/posts/go/golang%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/</link>
    <pubDate>Fri, 15 Feb 2019 15:03:44 &#43;0000</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/go/golang%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/</guid>
    <description><![CDATA[打包 // 打包 func Compress(destPath, srcDir string) error { // 压缩文件路径 	fw, err := os.Create(destPath) if err != nil { return err } defer fw.Close() // gzip writer 	gw := gzip.NewWriter(fw) defer gw.Close() // tar writer 	tw := tar.NewWriter(gw) defer tw.Close() // 读取要压缩的目录 	dir, err := os.Open(srcDir) if err != nil { return err } defer dir.Close() // 读取目录内容 	files, err := dir.Readdir(0) if err !]]></description>
</item><item>
    <title>Flask与Vue的token认证</title>
    <link>http://xingyys.tech/posts/python/flask%E4%B8%8Evue%E7%9A%84token%E8%AE%A4%E8%AF%81/</link>
    <pubDate>Wed, 20 Sep 2017 15:36:05 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/python/flask%E4%B8%8Evue%E7%9A%84token%E8%AE%A4%E8%AF%81/</guid>
    <description><![CDATA[后端使用flask设计基于token认证方式的restful接口，前端使用vue.js全家桶，利用axios通讯。
 感谢两篇文章的作者：
 http://www.cnblogs.com/vovlie/p/4182814.html https://segmentfault.com/a/1190000008383094?_ea=1639495  源码链接：https://github.com/xingyys/flaskvue
后端Flask Flask采用token认证方式，主要思路是通过/api/login登录获取token，然后使用token调用各个接口。 所用到框架的库：
 flask flask-cors：flask跨域 flask-sqlachemy: flask数据库orm flask-httpauth：flask的auth认证 passlib: python密码解析库 itsdangerous  后端结构图 flask/ ├── app # 主目录 │ ├── __init__.py │ ├── __init__.pyc │ ├── models.py # 数据库 │ ├── models.pyc │ ├── views.py # 视图 │ └── views.pyc ├── config.py # 配置信息 ├── config.pyc ├── db_create.py # 创建数据库 ├── db_migrate.py # 更新数据库 ├── db_repository │ ├── __init__.py │ ├── __init__.]]></description>
</item></channel>
</rss>
